# 第 10 章 函数

函数是**对象**, 每个函数都是 `Function` 类型的实例, 也有**属性**和**方法**

函数定义通常以**声明**的形式定义, 也可以用**表达式**定义
- 还有两种类似表达式的方式: **箭头函数**, **构造函数**
- 这几种实例化的方式**存在**微妙但重要的**差异**

## 目录

- [第 10 章 函数](#第-10-章-函数)
  - [目录](#目录)
  - [箭头函数](#箭头函数)
  - [函数名](#函数名)
  - [理解参数](#理解参数)
  - [没有重载](#没有重载)
  - [默认参数值](#默认参数值)
  - [实参展开 & 形参剩余](#实参展开--形参剩余)
  - [声明 vs. 表达式](#声明-vs-表达式)
  - [函数作为值](#函数作为值)
  - [函数内部](#函数内部)
  - [函数属性与方法](#函数属性与方法)
  - [函数表达式](#函数表达式)
  - [递归](#递归)
  - [尾调用优化](#尾调用优化)
    - [优化案例](#优化案例)
  - [闭包](#闭包)
  - [立即调用的函数表达式](#立即调用的函数表达式)
  - [私有变量](#私有变量)

## 箭头函数

`ECAMScript 6` 新增 `fat-arrow (=>)` 语法定义**函数表达式**

```js
let name = (param) => { function body }
```

- 只有一个**参数**, 可以省略括号
- 只有一行**语句**, 可以省略大括号, 此时会隐式返回改行语句的**值**

箭头函数语法简洁

- 但不能使用 `arguments, super, new.target`,
- 不能当作构造函数, 没有 `prototype`

## 函数名

函数名是指向函数的**指针**, 意味着一个函数可以有多个名称

使用**不带括号**的函数名访问函数指针

所有函数对象只暴露一个 `name` 属性, 多数情况是函数**标识符**
- 如使用 `Function` 创建, 则标识成 `"anonymous"`
- `getter, setter, bind()` 分别对应 `get, set, bound`

## 理解参数

`ECMAScript` 函数**不关心**参数的**数量**和**类型**

- **定义**时的参数数量不等于**调用**时的参数数量

参数在函数内部表现为一个**数组**, 可以通过 `argument` 对象访问
- 参数不限个数, 弥补不能重载的缺陷
- `argument` 和**有名参数**保持同步, 但在内存中分开存储

箭头函数内部没有 `argument`

所有参数**按值传递**, 不可能按引用传递 (引用也是一个值)

## 没有重载

`ECMAScript` 函数没有签名, 不能重载 (Overloading)

函数定义多次, 后定义的会**覆盖**先定义的

## 默认参数值

`ES6` 支持**显式**定义默认参数

传 `undefined` 等于**不传值**

`arguments` 对象不反映参数默认值

参数默认值可以是个**函数返回值**

默认参数作用域与暂时性死区
- 默认参数是按顺序定义的, 且**不能**引用**函数体**作用域
- **暂时性死区**即先定义的参数**不能**引用后定义的参数

## 实参展开 & 形参剩余

**Spread Arguments** and **Rest Parameter**

通过展开操作符 `...`
- 可以展开实际传入的数组, 将其元素一个个一次传入
- 

## 声明 vs. 表达式

`JavaScript` 引擎会先读取**函数声明**, 并会将其**提升**

**函数表达式**则需要等到代码执行到那一行, 与 `let` 或 `var` 无关

除此之外, 两者等价

## 函数作为值

**函数名是变量**, 所以函数可以用在任何可以使用变量的地方

- 函数作为**参数**传给另一个函数
- 在函数中**返回**另一个函数

## 函数内部

`arguments`

- 类数组对象, 包含**调用时**传入的所有参数, 箭头函数没有
- 属性 `callee`: 指向**所在函数**的指针

`this`

- 在**标准函数**中与**箭头函数**中分别有不同行为
  - 标准函数: 把函数当成方法调用的**语境对象**, 称为 `this` 值
  - 箭头函数: 保留定义该函数的**语境**

`caller`

- 调用当前函数的函数, 全局则为 `null`
- 对比当前函数 `arguments.callee`

`new.target`

- 是 `new` 的 target, 即是被 `new` 调用的

## 函数属性与方法

函数是对象, 因此有属性和方法

属性
- `length` 
- `prototype`

方法
- `apply()`
- `call()`
- `bind()`
- 将任意对象设置为任意函数的作用域

## 函数表达式

函数声明的特点是**函数声明提升**

函数表达式创建的函数叫**匿名函数** (`Anonymous or lambda functions`)

## 递归

函数**自己调用自己**

通过函数名, `callee`, 命名函数表达式

## 尾调用优化

尾调用: 外部函数返回值是内部函数的返回值

```js
function outerFunction() {
 return innerFunction(); // tail call
}
```

ES6 优化前: 每一次嵌套, 多一个栈帧
1. 进入 `outerFunction` 函数体, 第一个栈帧
2. 执行 `outerFunction` 函数体, 计算 `return` 即 `innerFunction`
3. 进入 `innerFunction` 函数体, 第二个栈帧
4. 执行 `innerFunction` 函数体, 计算 `return` ,返回
5. 回到 `outerFunction` , 返回
6. 栈帧依次弹出

ES6 优化后: 无论调用多少次嵌套, 都只有一个栈帧
1. 进入 `outerFunction` 函数体, 第一个栈帧
2. 执行 `outerFunction` 函数体, 计算 `return` 即 `innerFunction`
3. 发现 `innerFunction` 的返回也是 `outerFunction` 的返回
4. 弹出 `outerFunction` 栈帧
5. 进入 `innerFunction` 函数体, 第二个栈帧
6. 执行 `innerFunction` 函数体, 计算 `return` ,返回
7. 弹出 `innerFunction` 栈帧

优化条件: 确定外部栈帧无存在必要
- 严格模式 `"use strict";`
- 外函数返回值是对尾调用函数的调用
- 尾调用函数返回后无额外逻辑
- 尾调用函数不是引用外部函数作用域中自由变量的**闭包**

### 优化案例

递归计算斐波那契数列

```js
// memory complexity of O(2^n)
function fib(n) {
  if (n < 2) {
    return n;
  }
  return fib(n - 1) + fib(n - 2);
}
console.log(fib(1000));  // 内存炸了

// all tail call optimization requirements are satisfied
"use strict";

// base case
function fib(n) {
  return fibImpl(0, 1, n); 
}

// recursive case
function fibImpl(a, b, n) {
  if (n === 0) {
    return a;
  }
  return fibImpl(b, a + b, n - 1);
}

console.log(fib(1000));  // 4.346655768693743e+208
```

## 闭包

闭包指**引用了另一个函数作用域中的变量**的函数

作用域链
- 调用函数, 创建执行语境, 创建作用域链
- 向外串起所有包含函数活动对象, 直到全局执行语境
- 在执行语境中有个对象来代表变量

## 立即调用的函数表达式

## 私有变量

